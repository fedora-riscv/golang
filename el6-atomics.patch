diff -up go/misc/cgo/test/testx.go.rev ./go/misc/cgo/test/testx.go
--- go/misc/cgo/test/testx.go.rev	2020-08-26 19:36:41.493810467 +0200
+++ go/misc/cgo/test/testx.go	2020-08-26 19:36:48.498808001 +0200
@@ -83,18 +83,33 @@ extern void f7665(void);
 
 void issue7978cb(void);
 
+#if defined(__APPLE__) && defined(__arm__)
+// on Darwin/ARM, libSystem doesn't provide implementation of the __sync_fetch_and_add
+// primitive, and although gcc supports it, it doesn't inline its definition.
+// Clang could inline its definition, so we require clang on Darwin/ARM.
+#if defined(__clang__)
+#define HAS_SYNC_FETCH_AND_ADD 1
+#else
+#define HAS_SYNC_FETCH_AND_ADD 0
+#endif
+#else
+#define HAS_SYNC_FETCH_AND_ADD 1
+#endif
+
 // use ugly atomic variable sync since that doesn't require calling back into
 // Go code or OS dependencies
 static void issue7978c(uint32_t *sync) {
-	while(__atomic_load_n(sync, __ATOMIC_SEQ_CST) != 0)
+#if HAS_SYNC_FETCH_AND_ADD
+	while(__sync_fetch_and_add(sync, 0) != 0)
 		;
-	__atomic_add_fetch(sync, 1, __ATOMIC_SEQ_CST);
-	while(__atomic_load_n(sync, __ATOMIC_SEQ_CST) != 2)
+	__sync_fetch_and_add(sync, 1);
+	while(__sync_fetch_and_add(sync, 0) != 2)
 		;
 	issue7978cb();
-	__atomic_add_fetch(sync, 1, __ATOMIC_SEQ_CST);
-	while(__atomic_load_n(sync, __ATOMIC_SEQ_CST) != 6)
+	__sync_fetch_and_add(sync, 1);
+	while(__sync_fetch_and_add(sync, 0) != 6)
 		;
+#endif
 }
 
 // issue 8331 part 2 - part 1 in test.go
@@ -502,6 +517,9 @@ func test7978(t *testing.T) {
 	if runtime.Compiler == "gccgo" {
 		t.Skip("gccgo can not do stack traces of C code")
 	}
+	if C.HAS_SYNC_FETCH_AND_ADD == 0 {
+		t.Skip("clang required for __sync_fetch_and_add support on darwin/arm")
+	}
 	debug.SetTraceback("2")
 	issue7978sync = 0
 	go issue7978go()
